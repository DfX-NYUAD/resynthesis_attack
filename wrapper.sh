#!/bin/bash

## settings
#####

# NOTE points to path where this script resides; https://stackoverflow.com/a/246128
pwd_="$(cd -P "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

## NOTE/TODO these parameters are to be revised to match the setup at your end
source $pwd_/settings.sh

## check all parameters
#####
if [ $# -lt 1 ]; then
	echo 'Parameters required:'
	echo '1) Full path for locked bench file. Note that this helper will auto-generate and use a corresponding work dir in the same path, e.g., locked.bench -> locked.work'
	exit
fi
#
file_in=$1
if ! [[ -e $file_in ]]; then
	echo "Input file does not exist; check the provided path: \"$file_in\"."
	exit 1
elif [[ $file_in != *"/"* ]]; then
	echo "Input file is lacking path; check the provided path: \"$file_in\"."
	exit 1
elif [[ $file_in != *".bench" ]]; then
	echo "Input file seems to not be a bench file; check the provided path: \"$file_in\"."
	exit 1
fi

## derive runtime parameters
#####
# NOTE file name w/o path, w/ suffix
file_in_wo_path=${file_in##*/}
# NOTE file name w/o path, w/o suffix
file_in_name=${file_in_wo_path%.*}
# NOTE path name
file_in_path=${file_in%/*}
#
# other derived files; output files
work_dir=$file_in_path/$file_in_name'.work'
log_file=$file_in_name'.log'

## dbg
#echo $file_in_wo_path
#echo $file_in_name
#echo $file_in_path
#echo $log_file
#exit

## main code
#####

# 0) further init steps, along w/ sanity checks
##

correct_key_string_bench=$(ack "#key=" $file_in)
if [[ $correct_key_string_bench == "" ]]; then
	echo "Input file does not contain a line with the correct key, following the syntax '#key=[...]'; check the provided path: \"$file_in\"."
	exit 1
fi
# extract actual key bits
# NOTE keep 'correct_key_string_bench' separate as well, since we need to put this line back to converted bench files
correct_key_string=${correct_key_string_bench#\#key=}

# 1) generate and enter work dir
##

mkdir -p $work_dir
cd $work_dir

work_dir_full_path=$(pwd)

echo "" | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "Init and entering work dir: \"$work_dir\"" | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "" | tee -a $log_file

# 2) backup data of previous runs, if any
##
# NOTE ignore backup folders, and also trigger backup only for >1 files (as the log file is already 1 file)
if [[ $(ls | grep -v 'backup_' | wc -l) -gt 1 ]]; then

	backup_dir=backup_$(date +%s)

	mkdir $backup_dir

	for file in *; do
		if [[ $file != "backup_"* ]]; then
			mv $file $backup_dir/
		fi
	done

	echo "---------------------------------------------------------" | tee -a $log_file
	echo "Backup prior run data to: \"$work_dir/$backup_dir\"" | tee -a $log_file
	echo "---------------------------------------------------------" | tee -a $log_file
	echo "" | tee -a $log_file
fi

# 3) convert bench to verilog
##
echo "---------------------------------------------------------" | tee -a $log_file
echo "Converting input bench file \"$file_in_wo_path\" to verilog." | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "" | tee -a $log_file

# NOTE by construction, the input file is in the parent folder
$convert ../$file_in_wo_path b2v n

# 4) run resynth script
##
echo "" | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "Running resynth script; this will take some long time ..." | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "" | tee -a $log_file

# link from converted verilog to expected input file
ln -sf $file_in_name'.b2v.v' $verilog_in

# actual call to resynth script
# NOTE 'design_in' is the generic module name for all files; as generated by 'abc'
perl $synth -mod=design_in $synth_settings | tee -a $log_file

echo "" | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "Done running resynth script." | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "" | tee -a $log_file

# 5) prepare SCOPE
##
echo "---------------------------------------------------------" | tee -a $log_file
echo "Preparing SCOPE: convert all resynth verilog files back to bench, init local SCOPE copy, embedd key into bench files ..." | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "" | tee -a $log_file

# convert resynth verilog to bench
for file in design_*_mapped.v; do
	$convert ./$file v2b n
done

# carry over correct key from original bench file
for file in design_*_mapped.v2b.bench; do
	sed -i "1i$correct_key_string_bench" $file
done

# init local copy of SCOPE; required to enable parallel processing within different work dirs
#
mkdir SCOPE
#
mkdir SCOPE/abc_compiler
ln -sf $abc SCOPE/abc_compiler/
#
cp -ra $scope_dir/src SCOPE/
#
mkdir SCOPE/attacked_files
mkdir SCOPE/extracted_keys
mkdir SCOPE/feature_reports
mkdir SCOPE/obfus_tests

# link files into SCOPE work dir; must reside in there
for file in design_*_mapped.v2b.bench; do
	ln -sf ../../$file SCOPE/attacked_files/
done

# 6) run SCOPE on all bench files
##
echo "" | tee -a $log_file
echo "-------------------------------------------------------" | tee -a $log_file
echo "Running SCOPE attack; this may take some long time ..." | tee -a $log_file
echo "-------------------------------------------------------" | tee -a $log_file
echo "" | tee -a $log_file

# return silently back, out of work dir; just to put "previous pwd" back onto the "stack"
cd - > /dev/null
# jump to SCOPE dir; required for running SCOPE
cd $work_dir_full_path/SCOPE

# actual call to scope
./src/scope | tee -a ../$log_file

# 7) parse SCOPE results
##
# TODO parse results, do majority vote for each key bit across all SCOPE runs

# return silently back, out of SCOPE dir
cd - > /dev/null
