#!/bin/bash

## settings
#####

# NOTE points to path where this script resides; https://stackoverflow.com/a/246128
pwd_="$(cd -P "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

## NOTE/TODO these parameters are to be revised to match the setup at your end
source $pwd_/settings.sh

## check all parameters
#####
if [ $# -lt 1 ]; then
	echo 'Parameters required:'
	echo '1) Full path for locked bench file. Note that this helper will auto-generate and use a corresponding work dir in the same path, e.g., locked.bench -> locked.work'
	exit
fi
#
file_in=$1
if ! [[ -e $file_in ]]; then
	echo "Input file does not exist; check the provided path: \"$file_in\"."
	exit 1
elif [[ $file_in != *"/"* ]]; then
	echo "Input file is lacking path; check the provided path: \"$file_in\"."
	exit 1
elif [[ $file_in != *".bench" ]]; then
	echo "Input file seems to not be a bench file; check the provided path: \"$file_in\"."
	exit 1
fi

## derive runtime parameters
#####
# NOTE file name w/o path, w/ suffix
file_in_wo_path=${file_in##*/}
# NOTE file name w/o path, w/o suffix
file_in_name=${file_in_wo_path%.*}
# NOTE path name
file_in_path=${file_in%/*}
#
# other derived files; output files
work_dir=$file_in_path/$file_in_name'.work'
log_file=$file_in_name'.log'

## dbg
#echo $file_in_wo_path
#echo $file_in_name
#echo $file_in_path
#echo $log_file
#exit

## main code
#####

# 1) generate and enter work dir
##

mkdir -p $work_dir
cd $work_dir

work_dir_full_path=$(pwd)

echo "" | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "Init and entering work dir: \"$work_dir\"" | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "" | tee -a $log_file

# 2) backup data of previous runs, if any
##
# NOTE ignore backup folders, and also trigger backup only for >1 files (as the log file is already 1 file)
if [[ $(ls | grep -v 'backup_' | wc -l) -gt 1 ]]; then

	backup_dir=backup_$(date +%s)

	mkdir $backup_dir

	for file in *; do
		if [[ $file != "backup_"* ]]; then
			mv $file $backup_dir/
		fi
	done

	echo "---------------------------------------------------------" | tee -a $log_file
	echo "Backup prior run data to: \"$work_dir/$backup_dir\"" | tee -a $log_file
	echo "---------------------------------------------------------" | tee -a $log_file
	echo "" | tee -a $log_file
fi

# 3) convert bench to verilog
##
echo "---------------------------------------------------------" | tee -a $log_file
echo "Converting input bench file \"$file_in_wo_path\" to verilog." | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "" | tee -a $log_file

# NOTE by construction, the input file is in the parent folder
$convert ../$file_in_wo_path b2v n

# 4) run resynth script
##
echo "" | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "Running resynth script; this will take some long time ..." | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "" | tee -a $log_file

# link from converted verilog to expected input file
ln -sf $file_in_name'.b2v.v' $verilog_in

# actual call to resynth script
# NOTE 'design_in' is the generic module name for all files; as generated by 'abc'
perl $synth -mod=design_in $synth_settings | tee -a $log_file

echo "" | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "Done running resynth script." | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "" | tee -a $log_file

# 5) convert all resynth designs to bench files
##
echo "---------------------------------------------------------" | tee -a $log_file
echo "Converting all resynth verilog files back to bench." | tee -a $log_file
echo "---------------------------------------------------------" | tee -a $log_file
echo "" | tee -a $log_file

for file in design_*_mapped.v; do
	$convert ./$file v2b n
	file_out=$file_in_name'.v2b.bench'
done

# 6) run SCOPE on all bench files
##
echo "" | tee -a $log_file
echo "-------------------------------------------------------" | tee -a $log_file
echo "Running SCOPE attack; this will take some long time ..." | tee -a $log_file
echo "-------------------------------------------------------" | tee -a $log_file
echo "" | tee -a $log_file

# cleanup from any prior runs
rm $scope_dir/attacked_files/*
rm $scope_dir/attacked_files/.*.swp

# link files into SCOPE work dir; must reside in there
for file in design_*_mapped.v2b.bench; do
	ln -s $work_dir_full_path/$file $scope_dir/attacked_files/
done

# return silently back, out of work dir
cd - > /dev/null
# jump to SCOPE dir; required for running SCOPE
cd $scope_dir

# actual call to scope
./src/scope | tee -a $work_dir_full_path/$log_file

# 7) parse SCOPE results
##
# TODO

# return silently back, out of SCOPE dir
cd - > /dev/null
